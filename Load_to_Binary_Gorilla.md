<!-- TOC -->

- [What's this](#whats-this)
    - [必要な事前経験](#%E5%BF%85%E8%A6%81%E3%81%AA%E4%BA%8B%E5%89%8D%E7%B5%8C%E9%A8%93)
- [コンパイルとデコンパイル](#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%A8%E3%83%87%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB)
- [アセンブルとディスアセンブル](#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB%E3%81%A8%E3%83%87%E3%82%A3%E3%82%B9%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB)
    - [ニーモニック一覧](#%E3%83%8B%E3%83%BC%E3%83%A2%E3%83%8B%E3%83%83%E3%82%AF%E4%B8%80%E8%A6%A7)
- [x86アーキテクチャ](#x86%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3)
- [Main MemoryRAM](#main-memoryram)
- [用語集](#%E7%94%A8%E8%AA%9E%E9%9B%86)
- [スタック](#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF)
    - [プロローグとエピローグ](#%E3%83%97%E3%83%AD%E3%83%AD%E3%83%BC%E3%82%B0%E3%81%A8%E3%82%A8%E3%83%94%E3%83%AD%E3%83%BC%E3%82%B0)
    - [スタックフレーム](#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0)
    - [条件付きジャンプ](#%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97)
- [C言語の基礎](#c%E8%A8%80%E8%AA%9E%E3%81%AE%E5%9F%BA%E7%A4%8E)
- [Reversing: Secrets of Reverse Engineering](#reversing-secrets-of-reverse-engineering)
    - [Chapter2](#chapter2)
        - [低レイヤ基礎](#%E4%BD%8E%E3%83%AC%E3%82%A4%E3%83%A4%E5%9F%BA%E7%A4%8E)
        - [アセンブリ言語](#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E8%A8%80%E8%AA%9E)
            - [基礎的な演算](#%E5%9F%BA%E7%A4%8E%E7%9A%84%E3%81%AA%E6%BC%94%E7%AE%97)
            - [比較と条件分岐](#%E6%AF%94%E8%BC%83%E3%81%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90)
            - [レジスタ](#%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF)
        - [コンパイラ](#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9)
            - [GCC and G++ version 3.3.1](#gcc-and-g-version-331)
            - [Microsoft C/C++ Optimizing Compiler version 13.10.3077](#microsoft-cc-optimizing-compiler-version-13103077)
            - [Intel C++ Compiler version 8.0: The Intel C/C++](#intel-c-compiler-version-80-the-intel-cc)
- [Windows OS](#windows-os)
- [Corelan tutorial](#corelan-tutorial)
    - [あ](#%E3%81%82)
- [WinDbg](#windbg)
    - [概要](#%E6%A6%82%E8%A6%81)
    - [使い方](#%E4%BD%BF%E3%81%84%E6%96%B9)
    - [基本的なコマンド](#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89)
    - [参考資料](#%E5%8F%82%E8%80%83%E8%B3%87%E6%96%99)
- [メモ](#%E3%83%A1%E3%83%A2)
    - [金言的なヤツ](#%E9%87%91%E8%A8%80%E7%9A%84%E3%81%AA%E3%83%A4%E3%83%84)
        - [EIPについて](#eip%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)
    - [はじめてのエクスプロイトを書く際に理解が必要となる用語集](#%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%AE%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%97%E3%83%AD%E3%82%A4%E3%83%88%E3%82%92%E6%9B%B8%E3%81%8F%E9%9A%9B%E3%81%AB%E7%90%86%E8%A7%A3%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%AA%E3%82%8B%E7%94%A8%E8%AA%9E%E9%9B%86)
    - [目標](#%E7%9B%AE%E6%A8%99)
    - [スタックについてバイナリゴリラになるための最重要項目](#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E3%82%B4%E3%83%AA%E3%83%A9%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E6%9C%80%E9%87%8D%E8%A6%81%E9%A0%85%E7%9B%AE)
    - [Let's get started!](#lets-get-started)

<!-- /TOC -->
> Useful information that users should know, even when skimming content.

> [!TIP]
> Helpful advice for doing things better or more easily.

> [!IMPORTANT]
> Key information users need to know to achieve their goal.

> [!WARNING]
> Urgent info that needs immediate user attention to avoid problems.

> [!CAUTION]
> Advises about risks or negative outcomes of certain actions.



# What's this
**バイナリゴリラ**は、バイナリ解析がめっちゃできる人間のことです。
本書では、**push ebp**も分からない状態から初めてのBuffer Overflowの脆弱性を突いたC言語のエクスプロイトを書けるようになるまでを目標にしたドキュメントです。

## 必要な事前経験
本書を理解するために、以下が事前経験として求められます。
- C言語でHello Worldをしたことがある
- 何らかの言語でプログラミングをしたことがある
- コンパイル、デコンパイル、ディスアセンブルの単語を理解している
※C言語に自信が無い人は[CS50.jp](https://cs50.jp)のWeek1からWeek5を見てからLoad_to_Binary_Gorillaに進むことをお勧めします

# コンパイルとデコンパイル
コンパイラでコンパイルすると、C/C++といった高級言語がマシンコードに変換される。
このマシンコードをインプットしてIDAやGhidraなどのディスアセンブラを使ってアセンブリ言語を生成するプロセスがディスアセンブル


# アセンブルとディスアセンブル
高級言語からコンパイルされたマシンコードからアセンブリ言語を生成できる。マシンコードはアセンブリ言語のもう一つ下のレベルの言語。
16進数なので理解するのは難しい。

アセンブリ言語
```
push ebp
mov ebp, esp
sub esp, 0x40
```
> [!NOTE]
> アセンブリは、C言語などの高級言語で書かれたソースコードにアクセスできない場合に復元して読むことができる、最も高いレベルの言語。低レベルではマシンコード、マイクロコード、ハードウェアというのもあるが、ここは人間が理解するにはハードルが高い。

> [!TIP]
> 知らない命令を見かけたら、以下のx86に関するIntelのドキュメントを参照して調べられる。
http://www.intel.com/products/processor/manuals/index.htm

## ニーモニック一覧
ニーモニックとは以下のこと。**Instructions**の構成要素の一つで、 "ニーモニック" "オペランド"という形式で書かれる。オペランドには、レジスタやデータなどが書かれている。
mov
jmp
push
xor
test -> AND演算と同じ。AND演算の結果が0ならZF=1になる。要するに2つの値が等しいかどうか。　e.g) eax=0の場合、test eax eax -> ZF=1になる。 eax=55の場合、 test eax eax -> ZF=0になる
je -> ZFをチェックして、ZF=1なら、指定したラベルにJumpする。
cmp -> 二つのオペランド同士で減算を行う。二つの値の大小関係や、値同士が等しいかをチェックする。cmp eax edxの場合、eax - edxになる。二つのオペランドが等しい(結果が0)の場合、ZF=1になる。


![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/57c93fa6-db91-4d15-9ca9-98eefdcbd237)
>[!TIP]
>xor, or, and, shl, ror, shr, rolといったニーモニックが繰り返し出てくるような関数にあたった場合、マルウェア解析においては暗号化処理の部分にあたっている可能性がある

> [!TIP]
> Randall Hyde's氏著の**The Art of Assembly Language, 2nd Edition**は、x86アセンブリに馴染の無い初学者向けの良本


mov命令の基本
![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/1691f31d-bc13-45c5-bb0f-7c2e43684800)
> [!NOTES]
> movに似たものとして**lea**(load effective address)がある。これもコピーだが、メモリ内の値ではなくメモリアドレスそのものをコピーする点に注意。

# x86アーキテクチャ

まずは現代のノイマンコンピュータの内側を復習することが必須((+_+))
![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/7a7fa429-936d-49b5-83b9-c4f75c6b44bc)

- CPU
 - Control Unitはレジスタを使っていて、RAMから受け取った命令を実行する。この時、Control Unitは受け取る命令を**Instruction Pointer**で参照して、このポインタに書かれてるRAMのアドレスから命令を取ってくる。
 - ALU (arith metric unit)は、RAMから取ってきた命令を実行し、実行の結果をレジスタかメモリに保存する役割を持つ。

# Main Memory(RAM)
![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/f9eb88da-5257-4b85-93e3-9170ebf95aba)

 RAMは大まかに以下の領域で構成される。
 - Data.
  データセクション。プログラムがロードされたときに設定される値を含んでいる。Data.セクションにある値はStatic valueとも呼ばれていて、Static valueはプログラムの実行時に値が変更することがない。より分かりやすく言えば、このData.セクションに含まれている値はグローバル変数であり、プログラム内のどこからでも参照される値が格納されている。
 - Code.
   プログラム実行のためにCPUがRAMから命令をフェッチする際、その命令がこのCode.セクションに含まれている。
   実際にプログラムの動きを決めている部分なので大事。
 - Heap.
   プログラム実行に伴って動的に値を作成したり削除したりするときに使われる。
   Heap領域に格納されている値はプログラム実行時に頻繁に変更されるため、**dinamic memory**とも呼ばれる。
 - Stack.
   スタック領域は、関数実行時のローカル変数やパラメータのコントロール等で使われる。Buffer Overflowを目指すには深い理解が必須。
> [!NOTE]
> 上の図では順番にData. Code. Heap. Stack.となっているが、これらは必ずしもこの順番で並んでいる必要はない。実際にはメモリ全体にこれらのセクションが配置されていればいいので、順番が異なることはあり得る。





# 用語集
- オペコード => operation codeのこと。16進数で表されていて、CPUに何をしてほしいかが書いてある。オペコードは以下のように記述される。
  以下のB9...の部分がオペコード。movの方はアセンブリ言語に翻訳されたもの。
  ```
  Mnemonic Destination operand Source operand
  mov ecx, 0x42
  B9 42 00 00 00
  ```
  ![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/f6583a09-7a04-47c1-ae92-2db3423595ea)

- **リトルエンディアン** => x86はリトルエンディアンを使っている。リトルエンディアンはバイトを逆順で表す。x86はリトルエンディアンだが、ネットワークではビッグエンディアンなので、マシンコードを逆順に変換する作業が発生する点に注意。(IPアドレス等)
- **オペランド**
  => これは命令の中でデータを特定するために使われる。オペランドには以下の3種類がある。
  - Immediate operands => 0x42のような値
  - Register operands => ecxのような、レジストリを表す値
  - Memory address operands => [eax]のように、かっこで囲まれた値、レジスタ、または式で表され、目的値のメモリアドレスを指す。

- レジスタ <= 重要！
  => 実行速度が速いがデータ許容量の小さいストレージのこと。CPU上に存在し、CPUから直接アクセスするので速い。以下の4種類がある。

  1. General Registers
     => データとメモリアドレスを格納している。日本語だと汎用レジスタと呼ばれる。汎用レジスタは全て32bitで構成される。
     => レジスタごとに役割が決まっているものも多く、それらを知っておくと幸せになれる。
     例：EAXは関数の戻り値が格納される。乗除算命令にはEAXとEDXを使用する。etc...
  3. 
  >[!TIPS}
  >EIPについて => Instruction Pointerで、CPUに実行を命令するメモリアドレスを指す。この指しているアドレスに格納されているコードが壊れてると実行に失敗してクラッシュする。


# スタック

Last in First out (LIFO)で、x86はこのスタック構造をサポートしている。
レジスタは、ESPとEBPでスタック操作をサポート。
 - ESP => スタックポインタ
 - EBP => ベースポインタ 関数実行の際にローカル変数のメモリアドレスなどをオフセットとしてトレースできるように関数が始まるアドレスが格納される。
 - スタックではpush, pop, call, leave, enter, retなどのニーモニックがよく使われる。
 - 上位のメモリアドレスほどスタックの下へ。下位のメモリアドレス程スタックの上へ。0のアドレスに向かってスタックは伸びていく。
 - スタックはよく、ローカル変数、パラメータ、リターンアドレスを格納する。これらをEBPレジスタからのオフセットで参照する。
 - 引数は**push**でスタックの一番上に積まれる。
 - 関数は**call memory_location**のかたちで呼び出される。この時、その時点でEIPレジスタに保存されているメモリアドレスをスタックにpushする。なぜなら、callした関数の実行が終了した後に、元のメモリアドレスに戻る必要があるため。
 - 関数呼び出しの際は、ローカル変数とEBPレジスタ(ベースポインタ)の空間を確保するためにスペースがpushされる。
 - エピローグ。leave命令でESPとEBPを解放する。
 - 関数はret命令で元のアドレスに戻る。retは、関数call時にpushされていた戻りアドレスをpopしてEIPに格納する。
   >[!NOTE]
   >スタック内のローカル変数のスペースを確保する際、C言語で仮に128バイト確保していたとしても、アセンブリ上でも128バイト確保するとは限らない。これはコンパイラによって決定されるので、0x98バイトになったりすることもある。
   ## プロローグとエピローグ
   ## スタックフレーム
   EBPとESPで関数の最上位メモリアドレスと再会メモリアドレスを指定。例：EBP = 0x12F03C, ESP = 0x12F028
   ![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/06839449-1ab0-4080-ba83-379459b30aad)

## 条件付きジャンプ

   ![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/788a9b25-e457-41d6-9ebc-b1ca4565902a)
   ![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/bc0af24c-05c0-4b4e-9610-e8aaca047739)

# C言語の基礎
超シンプルなC言語のmain関数は以下になる。
argcはint型で、コマンドからプログラムを実行する時の引数の数とプログラムの名前を示す。argvは、コマンドラインから引数を入れたときの配列へのポインタを示す(?)
```.c
int main(int argc, char **argv
```

例：
```
filetestprogram.exe -r filename.txt

argc = 3
argv[0] = filetestprogram.exe
argv[1] = -r
argv[2] = filename.txt
```

```.c
int main(int argc, char* argv[])
{
    if(argc !=3) {return 0;}
    if(strncmp(argv[1], '-r', 2) ==0){
        DeleteFileA(argv[2]);

    }
    return 0;
}
```


# Reversing: Secrets of Reverse Engineering
## Chapter2
### 低レイヤ基礎
### アセンブリ言語
IA-32(Intel Architecture 32bit)では、以下の式で命令が一つずつ記述される。
```
Instruction Name(opcode) destination operand source operand
```
オペランドとなる値は大まかに以下の3つ。
1. レジスタ => EAXやEBXのような汎用レジスタの名称 例：**EAX**
2. Immediate => コードの中にハードコードされた文字列や定数を表す 例：**0x3000040
3. メモリアドレス => メモリアドレスは[]で囲まれる。 例：[0x4000349e] <- []で囲まれたImmediateなメモリアドレスは、グローバル変数である可能性がある。

>[!NOTE]
>上述されている文法は、IA-32の文法にのっとったもので、**AT&T**の文法とは異なる点に注意。大きく以下の点が異なる。AT&Tは主に、GNUなどのUNIX開発ツールで使用される。IntelはWindows向け。
> - destination operandとsource operandが逆
> - レジスタ名の先頭に%が付く。 例:%eax
> - IA-32でいう[]によるメモリアドレスの参照は、()として表記される。 例：%(ebx)　<-これで、EBXが指すメモリアドレス、という意味になる。
#### 基礎的な演算
1. ADD
2. SUB
3. MUL
    => 符号なしのEAXの数値を掛け算して、結果を64bitで保存する。保存先は**EDX:EAX** この意味は、下位32bitをEAXに保存して、上位32ビットをEDXに保存するという意味になる。IA-32では一般的な命令。
4. DIV
    => 符号なしの64bit値を割り算してEDX:EAXに符号なしで保存。商はEAX,余りはEDXに保存される。
5. IMUL
6. IDIV
7. CALL
    => CALLすると関数呼び出しになり、記載されている関数のアドレスにJMPする。実はこの時、裏側では関数呼び出し元の関数の戻りアドレスがPUSHされている点に注意。
#### 比較と条件分岐
1. CMP
2. ZF
    => 比較した二つのオペランドが等価だとセットされる
3. JNZ(jump if not zero)
    => ZFがセットされていない時に分岐先へジャンプする。実質**JNE(jump if not equal)**と同じニーモニック
   
#### レジスタ
- 汎用レジスタは8種類
  1. EAX
     整数、ブーリアン、論理といったメモリ演算に使用できる
  2. EBX
     整数、ブーリアン、論理といったメモリ演算に使用できる
  3. ECX
     演算にも使うが、繰り返し処理をするときのカウンタとしても使用される
  4. EDX
     整数、ブーリアン、論理といったメモリ演算に使用できる
  5. ESI
     メモリコピーにおいて、Source Indexとして使われることが多い
  6. EDI
     メモリコピーにおいて、Destination Indexとして使われることが多い
  7. EBP
     演算用の汎用的なレジスタとしても使われるが、スタックベースポインタとして使われることが多い。**ベースポインタ**は、ESPと一緒に使うことで、**スタックフレーム**を作ることができる。
  8. ESP
     CPUのスタックポインタを指す。現在のスタックの一番上のアドレスを格納しているので、スタックに値がpushされるたびにESPの値は更新される。
  >[!TIP]
  >これらのレジスタは**E**で始まっているが、これは**Extended**を表す。E系のレジスタは32bitのものだが、16bit Intelアーキテクチャの拡張版なので、Extendedがついている。
  >16bit IntelアーキテクチャではこれらのレジスタからEが外れて、AX, BX, CXのような名前だった。




### コンパイラ
現代ソフトウェアの99%はソースコードからコンパイラを使ってコンパイルしてからユーザに提供されている。
そのためリバエするときは、このコンパイラの挙動を把握することも重要になる。(コンパイラによってアセンブリに表示される挙動も変わる)
コンパイラに対する理解はオプションではなく**Must**らしい((+_+))
>[!NOTE]
>ここではコンパイラの表面しか扱わないので、ガチりたい人は以下を読むと良さげ
>[Cooper] Keith D. Copper and Linda Torczon. Engineering a Compiler. Morgan Kaufmann Publishers, 2004,
>[Muchnick] Steven S. Muchnick. Advanced Compiler Design and Implementation


ご存じの通りコンパイラは高級言語で書かれたソースコードを機械語へ翻訳するが、その過程で多くの最適化などのステップを踏む。
これによって、生成されるアセンブリがコンパイラによって異なったりする。基本的にコンパイラは以下のコンポーネントから構成される。

1. フロントエンド
2. オプティマイザ(最適化)
    =>コードを高速に実行して生成されるバイナリをなるべく小さくするためのテクニックを使用する。この最適化がリバエの時の障壁になったりするので、オプティマイザの理解がリバエにおいて重要になってくる。
3. バックエンド
    =>このバックエンドのステップが、コンパイラから生成されたアセンブリを読みにくくする。

#### GCC and G++ version 3.3.1
#### Microsoft C/C++ Optimizing Compiler version 13.10.3077
#### Intel C++ Compiler version 8.0: The Intel C/C++

=====================================================================

# Windows OS

# Corelan tutorial
以下のサイトを見ながら、バッファオーバーフローの脆弱性を実際にどうやって見つけて、どうやってエクスプロイトコードを書くかを体験する。
https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/

今回脆弱性が報告されたアプリケーションのPoCは以下。
https://www.exploit-db.com/exploits/10619

## あ
1. pythonでファイルを作ってEasyRMtoMP3Converterに食わせる
   1.1 以下のpythonスクリプトを作成して実行する
       ```.py
       file = 'crash.m3u'
       junk = 'A' * 10000
       f = open(file, 'w')
       f.write(junk)
       f.close()
       print('your exploit code created successfully')
       ```
       > [!NOTE]
       > Corelanの中ではPerlで書かれてるがPythonの方が一般的なのでPythonで書き直している。また、ここでは'A'の文字を10000回書き込んだファイルを作成している。       
   
   1.2 Converterに食わせる
        ドラッグアンドドロップで簡単に食わせることができる。以下のようになるはず。変な挙動。
![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/7768013b-d8d3-45fd-8651-18a6e31fa865)
![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/20ecccd3-89ae-473d-abd3-9b689782bb01)

2. バッファオーバーフローの検証
   2.1 簡単な配列を引数として受け取るプログラムを作成し、バッファオーバーフローを体験してみる

       ```.c
       void do_something(char *Buffer) {
           char my_var(128);
           strcpy(my_var, Buffer);
       }
       int main(int argc, char **argv) {
           do_someting(argv[1])
       }
       ```
       このプログラムに引数をAとして与えてみると、プログラムは実行できる。
   ![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/524609c1-b35d-48a6-91fb-acf69d826996)

       しかし、128文字引数をAで与えるとエラーが出る。
        ![image](https://github.com/cyber-mamba/red-teaming/assets/96987448/3bf8316b-d291-4d2d-ae87-41d4b91ee14b)
       これは、my_varの初期化の際に、128バイトまでしか値を受け取れないようにしているためである。Aは一つで1バイトだが、128文字入力したら128バイトで実行できそうに思われる。
       しかし実際には文字列の終端を表すNULL文字があるため、ユーザが実際に入力できる値は配列として確保された領域-1、つまり127バイト分までである。


# WinDbg
今回の演習ではBuffer Over Flowの脆弱性を使ってExploitコードを書きますが、スタックやメモリの動きをリアルタイムで把握するために、デバッガの使い方に慣れることは必須です。
マルウェア解析者であればx32やx64といったデバッガを使用することが多いかもしれません。また、これらのデバッガの方が視覚的に分かりやすい。

**しかし先駆者が「Windbgを使え！これが唯一の業界標準だ！」と言っていたので、とりあえずは黙ってWindbg使おう。**

WinDbgを使ってると玄人っぽくて**硬派なヤツ**感が出てカッコいいだろうというモチベーションで頑張って慣れるしかない。

## 概要
- クラッシュダンプの解析

## 使い方

## 基本的なコマンド

## 参考資料
[WinDbg をインストールしてとりあえず使えるところまで設定する方法](https://qiita.com/tokawa-ms/items/62625c7acc263185f530)


# メモ

## 金言的なヤツ

- クラッシュさせられたからと言って全てがエクスプロイトに繋がるわけではない。むしろほとんどはエクスプロイトに繋がらない。

- Exploitとは、「アプリケーションが意図していない動作を実行させること」であり、そのためにはアプリケーションをコントロール下に置く必要がある。

- つまり「アプリケーションをコントロール下におく」ということは、「Instruction(命令)ポインタを制御すること」である。
InsturctionポインタはEIPとしてこの後沢山出てくる。CPU内にあるレジスタの一つ。

### EIPについて

EIPはInstructionするポインタ。つまり「次の命令はこれ」とプログラムに指示するポインタのこと。実際にこのEIPはCPU内のレジスタの一つとして存在する。

EIPは別の関数に入る前に、現在実行している関数の戻りアドレスをEIPに保存する。これによって、関数の実行が終了した時のアドレスが分かる。この戻ったときのアドレス、つまりEIPに格納されているアドレス値を変更出来れば、次にプログラムが実行するコードを別のものにできる。(メモリ内の別のアドレスを指すことによって実現できる！)

攻撃者がアプリケーションをコントロールして本来とは違うコードを実行させたいわけだが、この実行させたいコードの事を特に**shellcode**と呼ぶ。

つまり、アプリケーションにshellcodeを実行させられれば我々の勝ち！

このshellcodeをアプリケーションに実行させるには、基本的にはEIPに格納されるメモリアドレスの値を、shellcodeが格納されたメモリアドレスにする必要がある。

また、このEIPというレジスタは**4バイト**になっている。(RIPだと8バイトで、IPだと2バイト。時代とともにかわてる。)
なので私たちが目指すのはこの**4バイト**の値を変更すること！


## はじめてのエクスプロイトを書く際に理解が必要となる用語集

1. Stack Based Overflows
2. .m3uファイル
3. shellcode => 実際にメモリの中で実行したいコード
4. スタックセグメント
5. バッファ
6. リトルエンディアン

## 目標

- Easy RM to MP3 conversion utilityというWindows XP向けのソフトの脆弱性を突いたエクスプロイトコードをゼロから書く。

    基本的には次ののレポートを参考にする。
    [Easy RM to MP3 Converter - '.m3u' Universal Stack Overflow](https://www.exploit-db.com/exploits/9186)

## スタックについて(バイナリゴリラになるための最重要項目)

## Let's get started!

1. まず30000このAを書き込んだ.m3uファイルをアプリケーションに食わせてクラッシュさせ、クラッシュ時のEIPの値を見る。
この時、EIPの値が41414141になっているはず。つまりこれは、EIPにメモリアドレスではなくさっき書き込んだ"A"が入っているということになる。

つまりこれが、バッファに.m3uファイルの一部("A")が読み込まれて、バッファがオーバーフローしたということになる。

上述の通りEIPは次に命令を実行するメモリのアドレス値を格納しているので、このままだと0x41414141のアドレスに飛んでそのメモリアドレスに入っているコードを実行することになる。しかしこのアドレスは空なので何も実行できずにクラッシュしている。

つまりファイル内のAAAA...を、飛ばしたいメモリアドレスに書き換えればいいわけだが、ここで一つ問題が生じる。
**Aを30000個書き込んだけど、このEIPに書いてある41414141ってどの"A"や...？

2. そう、いざEIPの値を自由に書き換えようと思っても、今のままではどこのAからオーバーフローになるのかが分からない。なのでまずはこれを正確に調べることから始める。

一応現段階で分かっていることは、このオーバーフローがトリガーされる値は20000～30000の間のどれか、ということ。

なぜなら先ほど10000と20000個のAを書き込んだファイルではアプリケーションはクラッシュせず、30000個書き込んでようやくクラッシュしたから。

3. 正確なバッファの特定のために、25000個のAと5000個のBをファイルに書き込んでみる。

このAとBが入ってるファイルでクラッシュさせると、EIPが42424242になる。
つまり25000～30000の間にバッファをオーバーフローさせるトリガーがあるはず((+_+))

4. これだとまだ25000～30000という範囲で広いので、Metasploitを使って正確なオフセットを把握する。
Metasploitは、.m3uファイル内に書き込む文字列をAやBだけでなく、それぞれ固有の文字にしてくれるので、それで正確なオフセットを計算することができる。

4.1 
Kaliでmetasploitを使っているので以下はKaliのコマンド
```
find / -name "*pattern_create*"
```

4.2
```
./pattern_create.rb -l 5000
```

4.3 pattern_createで作成した文字列をファイルに入れる。
つまりファイルは、Aが25000個に加え、ランダムな文字列が5000個ということになる。この状態でアプリケーションにファイルを食わせてEIPを確認する。

ここで、EIPの値が**326B4231**になっているはず。これはリトルエンディアンなので**31426B32**Cyberchef等でFrom Hexすると、**1BK2**になる。つまり、先ほどのpattern_createで作った文字列の内、1BK2がこのEIPに入っていることになる。
なので出力したhoge.txtのうち、25000+<1BK2の位置>がオフセットになる。

4.4 このオフセットの位置を計算するのは大変なのでKaliで**pattern_offset.rb**というツールを使う。

```
./pattern_offset.rb -q <EIPに入っていた値> 5000
```

これで1085が出力されるはず。
つまり25000+1085のAをぶっこんで、その次に26086番目から4バイト分に、アプリケーションのEIPに入れたい値をぶっこむ。

これでEIPにコントロール方法が分かった。また、ESPはバッファを指しているらしい。(このESPはスタックの一番上)

EIPは次に実行するコードが含まれたメモリアドレスを指すわけだが、ではこのアプリケーションを制御するためには我々はどこのメモリアドレスを指せばいいのか？また、このEIPで指すアドレスにはシェルコードを置きたいわけだが、どうやってその場所とサイズを特定すればいいのか？

5. もう一度先ほどのA,B,Cを含んだファイルを食わせてアプリケーションをクラッシュさせてみる。
次に、ESP, EAX, EBX, EBPをダンプしてみよう。
ESPにだけ、食わせるファイルにぶっこんだCが含まれているはずだ。
つまりこれが、私たちの実行したいshellcodeになる可能性があるということだ。

なのでこのCになっている部分、ESPが指すCをshellcodeにして、EIP(Bの部分)が指すアドレスをESPのアドレスにすればいいはず...

6. ということでCの部分をshellcodeに書き換えよう。
しかし現段階では、このESPに書き込まれているCは、Cの一番最初の値か分からない。shellcodeを書き込むときは、ESPにはちゃんとshellcodeの先頭から綺麗に含めるようにしないと動作しない。

6.1 更に正確にshellcodeの開始位置を把握するために以下のようなコードを使ってshellcodeの開始位置がどこからなのかを分かりやすくする。私は以下のPythonコードを使いました。

```.py
file = 'Afill.m3u'
a_data = 'A' * 26085
b_data = 'BBBB'
c_data ='0ABCDEFGHIJK''1ABCDEFGHIJK'+'2ABCDEFGHIJK'+'3ABCDEFGHIJK'+'4ABCDEFGHIJK' #これを9まで繰り返す

with open(file, 'w') as f:
    f.write(a_data+b_data+c_data)
    print('your exploit code created successfully')
```

6.2 次にこのファイルを食わせてクラッシュした時のESPをダンプしよう。

ESPのアドレスに入っている値を見ると、先頭はDEFGHIJK1AB...となっている。つまり先頭から5文字目がESPに入っていることになる。

現段階でどうなっているか整理しよう。

アプリケーションをクラッシュさせるためのデータ => A * 26085
書き換えたいEIPのデータ => B * 4
ESPのshellcodeのうち、最初の4バイト => X * 4
ESPに書き込まれるシェルコード => 1ABCDE...

ここで、ミソはshellcodeの最初の4バイト。preshellcodeの部分。これを入れたことで、ESPはDからではなく1ABCDEから始まるはず。

いま私たちは次のことができる。
1. EIPの書き換え
2. shellcodeの配置(少なくとも144byte以上)
3. ESPの指すアドレスは0x0016FBF8

もうこれで、アプリケーションをのとる準備が整った。なのでいい加減本物のshellcodeを作ろう。
また、EIPにはshellcodeが開始する先頭アドレスをぶっこもう。

7. 
以下のPythonコードで、EIP二よてジャンプさせる場所をESPの指すメモリアドレスにする。しかしこれはうまくいかない。
コードは以下。
```.py
```

このジャンプアドレスにはNULLバイトが含まれていて、また、OSやマシン、バージョンによってこのメモリアドレスは異なることがあるためうまくいかない可能性が高い。
なのでEIPに直接メモリアドレスを指すようにする戦法はあまり良くないとされている。

なので、ESPにジャンプするような関数を見つけて、その関数のアドレスをEIPで指すのが良さそう。

8. ということでESPにジャンプする関数を見つけ出したいが、ありがたいことにWindowsではESPにジャンプするDLLは一般的。なのでESPにジャンプするような関数は探せば見つけやすいはず。今回はこの、「ESPにジャンプするDLL」を探す。
この命令はオペコードで**jmp esp**と書かれる。
hexだとこれは**ffe4**となる。このffe4をDLLから探そう。

ffe4はMSRMCcodec02.dllの中にロードされている。
> [!TIPS]
> ここで、jmp espのメモリにはNULLバイトが含まれていないことをチェックすること。NULLバイトは以後の値を全て無視するのでshellcodeを含めない。

ということで、EIPの値をjmp espのアドレスにして、espにはshellcode を含めておこう。
今回はpre_shellcodeは一旦抜いてOK

9. すべての準備は整った... いい加減にshellcodeを作ってExploitをぶちかまそう！

-f cが大事。これやらないとC言語raw dataが出力できない。
```
msfvenom -p windows/exec CMD=calc.exe -b '\x80' -e x86/shikata_ga_nai -f c
```

